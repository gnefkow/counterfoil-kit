# 2.1: JavaScript Refresher (for the Rusty)

## Goal

Refresh the JavaScript you need to comfortably read Counterfoil component code: variables, functions, objects, arrays, modern syntax (destructuring, template literals, spread), and modules (`import`/`export`).

## Key terms

- **const / let**
- **function / arrow function**
- **object**
- **array**
- **callback**
- **destructuring**
- **template literal**
- **spread operator**
- **optional chaining**
- **ES modules**

## Main content

This chapter is not “learn JavaScript from scratch.” It’s a targeted refresh of what you’ll see repeatedly while reading this repo.

If you took a MERN bootcamp years ago, you probably remember the *ideas*. The drift is usually in:

- modern syntax (`const`, arrow functions, destructuring)
- array methods (`map`, `filter`, `reduce`)
- modules (`import`/`export`)

### Variables: `const`, `let`, `var` (what you actually need)

Use this simple rule:

- **`const`** for values you do not reassign (most things)
- **`let`** for values you do reassign
- **avoid `var`** in modern code

Counterfoil code mostly uses `const`.

From `src/App.tsx`:

```tsx
const tableRows = [
  { id: "INV-1042", customer: "Northwind Traders", amount: 1280.5 },
  // ...
]

const totalAmount = tableRows.reduce((sum, row) => sum + row.amount, 0)
```

Even though `tableRows` is an array, it’s still `const` because the *variable* is not being reassigned. (`const` does not mean “immutable,” it means “this name won’t point somewhere else.”)

### Functions: regular vs arrow (and why arrows are everywhere)

You’ll see two shapes:

1) **Regular function declarations** (common for React components):

From `src/components/primitives/Stack.tsx`:

```tsx
export function Stack({ children, gap = "m", className }: StackProps) {
  return (
    <div className={[`flex flex-col ${gapClasses[gap]}`, className].filter(Boolean).join(" ")}>
      {children}
    </div>
  )
}
```

2) **Arrow functions** (common for callbacks and short functions):

From `src/components/form/Input.tsx`:

```tsx
onChange={(e) => onChange?.(e.target.value)}
```

Arrow functions are used heavily because they’re concise and work naturally as “pass a function into another function” (a callback).

#### What a callback is

A callback is “a function you give to something else so it can call it later.”

Examples in this repo:

- `onChange={(e) => ...}`: the browser calls your function when input changes
- `tableRows.reduce((sum, row) => ...)`: `reduce` calls your function for each row
- `onSelect={(id) => setActiveTab(...)}`: a component calls your function when a tab is selected

### Objects: `{ key: value }` and “shape of data”

Objects are used constantly to represent real-world records and component props.

From `src/App.tsx`:

```tsx
{
  id: "INV-1042",
  customer: "Northwind Traders",
  status: "Paid",
  createdAt: "2026-01-12",
  amount: 1280.5,
}
```

Three common “reading moves”:

- **Dot access**: `row.amount`
- **Object literal**: `{ id: "...", amount: 10 }`
- **Object in arrays**: `[{...}, {...}]`

### Arrays: the three methods you must be able to read

If you can read these, you can read a large portion of modern React/JS code:

- `map` (transform items)
- `filter` (keep some items)
- `reduce` (combine items into one result)

#### `map`: one item in, one item out

In React, `map` is commonly used to render a list.

From `src/App.tsx`:

```tsx
tableRows.map((row, idx) => (
  <TableRow key={row.id} selected={idx === 0}>
    <TableCell>{row.id}</TableCell>
    <TableCell numeric>${row.amount.toFixed(2)}</TableCell>
  </TableRow>
))
```

How to read it:

- For each `row` (and its index `idx`), return a `TableRow` element.
- `key={row.id}` is a React requirement for list rendering.
- `selected={idx === 0}` is just a boolean expression.

#### `filter`: keep the “truthy” ones

This repo uses a common pattern for building class strings:

From `src/components/primitives/Stack.tsx`:

```tsx
[`flex flex-col ${gapClasses[gap]}`, className].filter(Boolean).join(" ")
```

How to read it:

- Build an array of class-string pieces.
- `.filter(Boolean)` removes falsy values (`undefined`, `null`, `""`, `false`).
  - This matters because `className` is optional.
- `.join(" ")` turns `["a", "b"]` into `"a b"`.

This is a very common “className assembly” move in React codebases.

#### `reduce`: combine many items into one

From `src/App.tsx`:

```tsx
const totalAmount = tableRows.reduce((sum, row) => sum + row.amount, 0)
```

How to read it:

- Start with `sum = 0`.
- For each `row`, add `row.amount` to `sum`.
- At the end, `totalAmount` is the sum of all amounts.

### ES6+ syntax you will see constantly

#### Destructuring (pulling fields out of an object)

Destructuring is basically “take properties from an object and bind them to local names.”

From `src/components/form/InputField.tsx`:

```tsx
export function InputField({
  label,
  description,
  helpText,
  errorText,
  icon,
  type,
  value,
  defaultValue,
  placeholder,
  disabled = false,
  name,
  id,
  onChange,
}: InputFieldProps) {
  const hasError = Boolean(errorText)
  // ...
}
```

How to read it:

- The function receives one object (“props”).
- We immediately pull out the specific properties we care about.
- `disabled = false` is a default value (if prop is missing/undefined).

If destructuring feels noisy, a mental translation is:

```ts
function InputField(props) {
  const label = props.label
  const disabled = props.disabled ?? false
  // ...
}
```

#### Template literals (string interpolation)

Template literals use backticks and `${...}` for interpolation.

From `src/components/primitives/Stack.tsx`:

```tsx
`flex flex-col ${gapClasses[gap]}`
```

How to read it:

- This is a string.
- It includes another string computed from `gapClasses[gap]`.

#### Spread operator (`...`)

You’ll see spread in many React codebases for:

- copying objects/arrays
- merging props
- building new arrays

This repo’s component files (at least in the primitives we’ve looked at) don’t lean heavily on spread, but you’ll likely use it as you evolve the kit.

Two patterns to remember:

```js
const next = [...items, newItem]         // copy array + add item
const merged = { ...defaults, ...overrides } // copy object + override fields
```

#### Optional chaining (`?.`)

Optional chaining is “call it only if it exists.”

From `src/components/form/Input.tsx`:

```tsx
onChange={(e) => onChange?.(e.target.value)}
```

How to read it:

- If `onChange` was passed in, call it with `e.target.value`.
- If it wasn’t passed in, do nothing.

This is a clean way to support optional callbacks.

### Modules: `import` and `export` (how code is organized)

Modern JavaScript uses ES Modules:

- `import` pulls values from another file
- `export` makes values available to other files

From `src/App.tsx`:

```tsx
import { Button, Card, Inline, Stack, Text } from "./components/primitives"
import { CheckboxField, InputField, RadioField, TextareaField } from "./components/form"
```

That tells you immediately:

- this file is composed out of other modules
- those modules export named values (components)

And from a component file:

From `src/components/form/Input.tsx`:

```tsx
export function Input({ /* ... */ }: InputProps) {
  // ...
}
```

That `export` means other modules can import `Input`.

One library-specific anchor: Counterfoil’s root exports are collected in `src/index.ts`.

From `src/index.ts`:

```ts
export * from "./components/primitives"
export * from "./components/form"
// ...
```

That pattern is called a “barrel export”: it creates a single entrypoint for consumers. (We’ll return to this in `2.11 Packaging and Releasing`.)

### A note about TypeScript syntax in code snippets

In this repo, most files are `.ts`/`.tsx`, so you’ll occasionally see syntax that looks like “JavaScript plus extra punctuation.”

For example, in `src/App.tsx` you’ll see:

```tsx
const [activeTab, setActiveTab] = React.useState<
  "typography" | "buttons" | "form" | "table"
>("typography")
```

That angle-bracket part (`< ... >`) is TypeScript telling React what type of state is allowed.

For now, you can read this as:

- `activeTab` is state
- it starts as `"typography"`
- later chapters will explain the type syntax in detail

(See `2.2 What Are Types` and `2.3 TypeScript`.)

## Next chapter

In `2.2 What Are Types and Why Do They Matter?`, we’ll explain what “types” buy you in practice (and why Counterfoil leans on them heavily) before learning TypeScript syntax. (See `2.2 What Are Types and Why Do They Matter?`.)
