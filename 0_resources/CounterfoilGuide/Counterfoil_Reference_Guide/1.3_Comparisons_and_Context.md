# 1.3: Comparisons and Context

## Goal

Be able to look at a UI toolkit and quickly answer:

- **What is it giving me?** (components, CSS, tokens, patterns)
- **Where do I change things?** (theme, styles, behavior, structure)
- **How “opinionated” is it?** (how much it decides for you)
- **What will it feel like to maintain?** (when you need to evolve the system)

This chapter compares Counterfoil to Material Design and Bootstrap (and briefly other React UI libraries) at the level that matters for reading and evolving code: **files, packages, entrypoints, and customization surfaces**.

## Key terms

- **design system**
- **component library**
- **opinionated**
- **theme**
- **tokens**
- **CSS variables**
- **utility classes**
- **entrypoint**
- **exports map**
- **peer dependency**

## Main content

If you’re reading this guide, you’re not trying to “pick the best UI library.” You’re trying to build and evolve *your* system with less confusion.

So the comparisons here aren’t aesthetic (“which looks better”)—they’re structural:

- What the library *ships* and how you import it
- Whether styling is “CSS-first” or “JS-first”
- Whether “theme” is a token layer you can override or a framework you must buy into
- How hard it is to extend without forking

### A quick baseline: what Counterfoil is, structurally

Counterfoil is published as an npm package with explicit entrypoints for:

- **runtime JS**
- **TypeScript types**
- **CSS styles** (tokens + Tailwind plumbing)
- **a Tailwind preset** for reuse

From `package.json`:

```json
{
  "name": "counterfoil-starter-kit",
  "peerDependencies": {
    "react": "^18.0.0 || ^19.0.0",
    "react-dom": "^18.0.0 || ^19.0.0"
  },
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/counterfoil-kit.es.js",
      "require": "./dist/counterfoil-kit.umd.js"
    },
    "./styles/semanticTokens.css": {
      "import": "./dist/semanticTokens.css",
      "require": "./dist/semanticTokens.css"
    },
    "./styles/base.css": {
      "import": "./dist/base.css",
      "require": "./dist/base.css"
    },
    "./tailwind-preset": "./tailwind.config.cjs"
  }
}
```

That `exports` block is a big deal. It means Counterfoil wants you to interact through:

- `counterfoil-starter-kit` (components)
- `counterfoil-starter-kit/styles/*` (CSS)
- `counterfoil-starter-kit/tailwind-preset` (Tailwind mapping)

In other words: Counterfoil’s customization surface is designed to be **mostly outside component code**:

- change token values → change look
- keep components boring → reduce hidden coupling

(See `1.2 How They Fit Together`.)

### Material Design: concept vs implementation

“Material Design” is two different things people conflate:

1. **A design language/spec** (guidelines, interaction patterns, visual grammar)
2. **A concrete implementation** (often a React component library, e.g. MUI)

When you say “Material” in a codebase context, you usually mean (2): you installed a package that gives you components + theming + styling decisions.

#### What Material-style libraries provide

Typically:

- A large set of ready-to-use components (not just primitives)
- A theming system (often JS-driven)
- A default visual language that is hard to fully escape without significant work

This is “opinionated” in the strong sense: it tries to be a complete system.

#### How Counterfoil is different from Material (structurally)

Material-style libraries generally emphasize:

- **pre-built components** (“use this Dialog/DatePicker/Menu”)
- **a framework theming API** (often JS objects)
- a lot of internal styling complexity to support customization knobs

Counterfoil emphasizes:

- **primitives + composable building blocks**
- **CSS tokens** as the primary theming mechanism
- Tailwind utilities as the “styling language” inside components

If you want one concrete contrast:

- In Counterfoil, **colors are CSS variables**.
- Tailwind config maps those variables to utilities.
- Components consume the semantic utilities.

From `src/styles/semanticTokens.css`:

```css
:root {
  --bg-primary: #ffffff;
  --text-primary: #000000;
}
```

From `tailwind.config.cjs`:

```js
colors: {
  bg: { primary: "var(--bg-primary)" },
  text: { primary: "var(--text-primary)" }
}
```

Material-style libraries may offer tokens, but often the “center” is a JS theme object and library-provided styling engine. Counterfoil’s center is “CSS you can inspect.”

#### How Counterfoil is similar to Material

Both share the key premise:

- You don’t build UI from raw HTML and random CSS.
- You build UI out of reusable components with consistent patterns.

Counterfoil is just less prescriptive about what those patterns *must* be.

#### When to use Material vs Counterfoil (decision guide)

Choose a Material-style library when:

- You want a comprehensive set of components quickly
- You’re okay with “Material-ish” defaults
- You prefer a strong theming API over total styling transparency

Choose Counterfoil when:

- You want to own your system’s look and semantics
- You want theming to be **CSS-variable-first**
- You want a kit that stays legible as it grows

### Bootstrap: what it actually is in code terms

Bootstrap is primarily:

- a CSS framework (and historically some JS for interactive components)
- a set of **pre-styled components** expressed as class patterns

In practice, “using Bootstrap” often means:

- you add a CSS file to your project
- you write HTML/JSX with Bootstrap’s class names (e.g. `btn btn-primary`)
- you accept the default look, or you override it by writing CSS/Sass

#### What Bootstrap provides

- A big set of pre-defined class names that produce a consistent UI
- Layout helpers (grid, spacing utilities)
- A default aesthetic that “just looks like Bootstrap”

Bootstrap’s main interface is not “a typed component API.” It’s a **class-name vocabulary**.

#### How Counterfoil is different from Bootstrap (structurally)

Counterfoil’s default interface is **components**, not class recipes.

From `src/index.ts`:

```ts
export * from "./components/primitives"
export * from "./components/form"
export * from "./components/data"
export * from "./components/navigation"
export * from "./icons"
```

That means most of your UI usage looks like:

- `<Button variant="primary" />`
- `<InputField label="Email" />`

…instead of:

- `<button className="btn btn-primary">`
- `<input className="form-control">`

Counterfoil also bakes theming into a token layer:

- tokens exist as CSS variables (`semanticTokens.css`)
- Tailwind config maps those variables to semantic utilities (`tailwind.config.cjs`)
- components use the mapped vocabulary

Bootstrap *can* be themed, but it’s not inherently “semantic-token-first” unless you invest in a theming layer yourself.

#### How Counterfoil is similar to Bootstrap

They share one important idea:

- **A constrained vocabulary beats one-off CSS.**

Bootstrap constrains you with a fixed set of classes.
Counterfoil constrains you with:

- tokens (semantic meanings)
- utilities (Tailwind mapping)
- components (pre-defined interfaces)

In both cases, the goal is consistency through a shared language.

#### When to use Bootstrap vs Counterfoil (decision guide)

Choose Bootstrap when:

- you want a fast, familiar, “good enough” UI baseline
- you’re okay with Bootstrap’s look (or you’re willing to fight it)
- you want to stay mostly in HTML + class names

Choose Counterfoil when:

- you want your *own* design semantics and token vocabulary
- you want React components to express the system’s API
- you want theming to be “edit CSS variables” instead of “rewrite component CSS”

### Other component libraries (Chakra, MUI, etc.): what they share

Most React UI libraries in the “Chakra/MUI/Mantine/Ant” family share a similar shape:

- install a package
- import a lot of components
- get a theming system (sometimes heavy)
- accept that a lot of styling logic lives inside the library

This is not “bad.” It just has consequences when you need to evolve the system.

#### How they’re similar to Counterfoil

- They provide **components** and a consistent vocabulary.
- They expose a public API that you use everywhere (often via props).
- They aim to reduce the amount of ad-hoc CSS you write.

#### How they’re different from Counterfoil

Counterfoil’s center of gravity is:

- **CSS variables as tokens**
- **Tailwind mapping as the translation layer**
- **components that stay close to HTML + class strings**

In Counterfoil, a lot of the system is readable without “learning the library’s special theming API.”

For example, Counterfoil’s `Button` variants and allowed sizes are explicit in the file itself.

From `src/components/primitives/Button.tsx`:

```tsx
type ButtonVariant =
  | "primary"
  | "secondary"
  | "tertiary"
  | "quaternary"
  | "link"
  | "destructive-primary"
  | "destructive-secondary"

const variantClasses: Record<ButtonVariant, string> = {
  primary:
    "bg-[var(--button-primary-bg)] text-[var(--button-primary-text)] " +
    "hover:bg-[var(--button-primary-bg-hover)] " +
    "active:bg-[var(--button-primary-bg-active)] " +
    "focus-visible:ring-button-primary",
  // ...
}
```

Reading posture:

- The **type** tells you what variants exist.
- The **class map** tells you what each variant does.
- The **tokens** tell you what values are behind those meanings.

That “layered readability” is what makes Counterfoil feel more like a toolkit you can grow, rather than a black box you configure.

#### When Counterfoil fits vs. doesn’t fit

Counterfoil fits when:

- you care about controlling semantics and tokens long-term
- you want to keep theming mostly in CSS variables
- you want to read and modify the system without learning a large, library-specific theming API

Counterfoil may not fit when:

- you want a huge component catalog today (date pickers, complex data grids, etc.)
- you want “batteries included” patterns everywhere, with strong defaults
- you need to match an existing design language that a library already implements well

### A quick comparison matrix (what you’ll actually touch)

| System | Primary UI interface | Styling center | Theming surface | Typical “extension” path |
| --- | --- | --- | --- | --- |
| Bootstrap | Class names on HTML/JSX | CSS utilities + component classes | Sass vars / CSS overrides | Override CSS, add custom classes |
| Material-style (e.g. MUI) | React components | Library styling engine + theme API | JS theme object (plus tokens) | Use theming API, override components, sometimes wrap |
| Counterfoil | React components + Tailwind classes | CSS variables + Tailwind mapping | Edit tokens in CSS variables | Add tokens + map to utilities + add/compose components |

This is the key idea:

- If your main goal is **speed** and “good defaults,” a complete system (Bootstrap/Material) can be great.
- If your main goal is **legibility + ownership**, Counterfoil’s token-first structure is a better fit.

## Next chapter

In `1.4 What Counterfoil Is and Isn’t`, we’ll turn the comparisons into boundaries: what this kit is designed to do well, what it intentionally does not do, and what “using something else” looks like in practice. (See `1.4 What Counterfoil Is and Isn't`.)


