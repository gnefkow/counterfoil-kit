# 1.2: How They Fit Together

## Goal

Get a clear mental model of the Counterfoil pipeline—**tokens → Tailwind mapping → component code → Vite build output**—and know which file to open when something looks wrong.

## Key terms

- **CSS variables**
- **semantic tokens**
- **Tailwind utilities**
- **Tailwind config**
- **@config**
- **@tailwind layers**
- **entrypoint**
- **bundle**

## Main content

At a high level, Counterfoil is organized so that:

- **Design meaning and values live in CSS variables** (semantic tokens).
- **Tailwind maps those variables into usable class names** (utilities).
- **Components apply those class names** (plus small bits of logic).
- **Vite runs the whole pipeline** in development and builds publishable artifacts.

If you remember only one thing, remember this boundary:

- **Change “what it looks like”** → usually `src/styles/semanticTokens.css`
- **Change “what classes mean”** → `tailwind.config.cjs`
- **Change “how Tailwind is activated / wired”** → `src/styles/base.css`
- **Change “how UI behaves / renders”** → component files in `src/components/**`

### Step 1: Semantic tokens define meaning (CSS variables)

Tokens are plain CSS variables. They’re meant to be readable, inspectable, and overrideable.

From `src/styles/semanticTokens.css`:

```css
:root {
  /* Backgrounds */
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-surface: #020617;

  /* Text */
  --text-primary: #000000;
  --text-secondary: #3C3D47;
  /* ... */
}
```

This file is intentionally “design meaning + values only.” No Tailwind directives, no build tooling. (See `2.6 Understanding CSS` and `3.4 Reading Semantic Tokens`.)

### Step 2: Tailwind config translates tokens into utilities

Tailwind becomes useful when you can write ergonomic class names instead of `style={{ ... }}` everywhere.

Counterfoil uses Tailwind’s config to map semantic tokens to Tailwind’s theme values, so utilities resolve to `var(--token-name)`.

From `tailwind.config.cjs`:

```js
colors: {
  bg: {
    primary: "var(--bg-primary)",
    secondary: "var(--bg-secondary)",
    surface: "var(--bg-surface)",
  },
  text: {
    primary: "var(--text-primary)",
    secondary: "var(--text-secondary)",
  },
}
```

That mapping is the “translation layer.” It answers questions like:

- “When I write `text-text-primary`, what value is that?”
- “Where does `bg-bg-surface` come from?”

(See `2.7 Tailwind CSS` and `3.5 Reading Tailwind Config`.)

### Step 3: `base.css` is where Tailwind gets activated

Tailwind doesn’t do anything unless it’s “turned on” in an input CSS file. In Counterfoil, that’s `src/styles/base.css`.

From `src/styles/base.css`:

```css
@config "../../tailwind.config.cjs";

@tailwind base;
@tailwind components;
@tailwind utilities;
```

Two important points:

- `@tailwind ...` tells Tailwind which **layers** to generate.
- `@config ...` explicitly points Tailwind v4 at the config file to use.

This is “plumbing,” not design. The goal is: if you replace Tailwind someday, you mostly replace plumbing, not your token meanings.

(See `2.8 Where Tailwind Gets Wired` for the detailed explanation.)

### Step 4: The style entrypoint controls import order

You need both:

- tokens (CSS variables exist)
- Tailwind output (utilities exist)

Counterfoil provides a single “import both” CSS entrypoint.

From `src/styles/index.css`:

```css
@import "./semanticTokens.css";
@import "./base.css";
```

In this repo’s app entrypoint, those are imported directly so the dev app renders correctly.

From `src/main.tsx`:

```tsx
import "./styles/semanticTokens.css"
import "./styles/base.css"
```

Notice the order: **tokens first**, then Tailwind plumbing.

### Step 5: Components use the utilities (and stay mostly boring)

Components should read like “apply semantic utilities + small behavior.”

From `src/components/form/Input.tsx`:

```tsx
className={[
  "w-full rounded",
  "bg-input-bg border border-input-border",
  "px-3 py-2",
  "text-body-1 text-text-primary",
  "placeholder:text-input-placeholder",
  "focus:outline-none focus-visible:ring-2 focus-visible:ring-input focus-visible:ring-offset-2",
  "disabled:opacity-60 disabled:cursor-not-allowed",
].join(" ")}
```

What’s happening here:

- “Plain” utilities handle layout/spacing (`w-full`, `px-3`, `py-2`).
- Semantic utilities handle design meaning (`bg-input-bg`, `text-text-primary`), which ultimately resolve to CSS variables.
- State modifiers (`focus-visible:`, `disabled:`) express interaction behavior in a readable way.

If you later change `--input-bg` in `semanticTokens.css`, the component changes appearance **without changing component code**. That’s the point.

### Step 6: Vite runs the pipeline (dev + build)

Vite is the coordinator:

- compiles TypeScript/JSX
- runs Tailwind on your CSS input
- serves the app in dev
- builds artifacts for production (and for publishing the library)

You can see the two workflows in the scripts.

From `package.json`:

```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:lib": "vite build --config vite.lib.config.ts && node scripts/build-styles.mjs"
  }
}
```

In practice:

- When you’re iterating locally, you care about `dev`.
- When you’re publishing to npm, you care about `build:lib`.

(See `2.10 Understanding the Build Pipeline` and `2.11 Packaging and Releasing`.)

### Quick “where do I look?” checklist

When something is wrong, don’t guess—follow the pipeline:

- **Wrong color/spacing/typography value** → `src/styles/semanticTokens.css`
- **A semantic class doesn’t exist / doesn’t resolve** → `tailwind.config.cjs`
- **Tailwind classes aren’t doing anything at all** → `src/styles/base.css` and import order
- **A component renders “wrong” structurally** → the component file (props/JSX/logic)
- **A consuming app can’t import styles/types** → `package.json` `exports` (See `2.11 Packaging and Releasing`.)

## Next chapter

In `1.3 Comparisons and Context`, we’ll compare Counterfoil’s structure to Material Design and Bootstrap in practical terms: how each one “packages” components and styling, and what that implies when you read or extend the code. (See `1.3 Comparisons and Context`.)

