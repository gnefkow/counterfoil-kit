# 1.1: The Shallow Overview

## Goal

Understand what Counterfoil is “made of” (React, TypeScript, Tailwind, Vite), what each piece is responsible for, and what you should expect to see when reading the codebase.

## Key terms

- **component library**
- **React**
- **TypeScript**
- **types**
- **Tailwind CSS**
- **design tokens**
- **semantic tokens**
- **build tool**
- **Vite**
- **package.json exports**

## Main content

Counterfoil is a **component library**: a set of reusable UI building blocks (Button, Input, Table, layout primitives, etc.) intended to be imported into an application.

The core idea is simple:

- You build UI by composing components.
- Components have **props** (inputs) and return **JSX** (rendered UI).
- Styling is expressed through **semantic tokens** (CSS variables) and **Tailwind utilities** (classes).
- A build system (Vite) turns source code into something your browser (and other apps) can run.

This chapter is a shallow map of those pieces so later chapters can go deep without you getting lost.

### What Counterfoil ships (as a package)

When you publish a library, consumers don’t import your `src/` folder directly. They import what you publish: JavaScript bundles, CSS, and types.

In Counterfoil, the “contract” for what the package exposes is in `package.json`.

From `package.json`:

```json
{
  "name": "counterfoil-starter-kit",
  "type": "module",
  "main": "./dist/counterfoil-kit.umd.js",
  "module": "./dist/counterfoil-kit.es.js",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/counterfoil-kit.es.js",
      "require": "./dist/counterfoil-kit.umd.js"
    },
    "./styles": {
      "import": "./dist/styles.css",
      "require": "./dist/styles.css"
    },
    "./styles/semanticTokens.css": {
      "import": "./dist/semanticTokens.css",
      "require": "./dist/semanticTokens.css"
    },
    "./styles/base.css": {
      "import": "./dist/base.css",
      "require": "./dist/base.css"
    },
    "./tailwind-preset": "./tailwind.config.cjs"
  }
}
```

The important takeaway:

- **JavaScript**: the runtime code consumers import (ESM and UMD builds).
- **Types**: the `.d.ts` files TypeScript uses to understand the library’s API.
- **Styles**: CSS entrypoints, including a semantic token file and a “base” style file.
- **Tailwind preset**: an export specifically for Tailwind configuration reuse.

You don’t need to memorize this now. You just need to know Counterfoil is designed to be consumed as a real package with explicit entrypoints, not as a pile of copy-pasted components.

### React (what it is, why it’s here)

**What it is (two sentences):** React is a JavaScript library for building user interfaces using components. Components are functions that turn props (inputs) into JSX (a description of UI).

**Why Counterfoil uses it (practical reasons):**

- **The UI is naturally component-shaped**: Button, Input, Card, Table, etc.
- **Your team already speaks React** (and if you hire later, the talent pool is large).
- **Composability is the default**: small pieces can be assembled into larger patterns without needing a “framework-specific” design tool.

If you want a concrete anchor: Counterfoil’s public API is largely “export a bunch of components.”

From `src/index.ts`:

```ts
export * from "./components/primitives"
export * from "./components/form"
export * from "./components/data"
export * from "./components/navigation"
export * from "./icons"
```

That is the library’s core shape: a curated set of React components grouped by purpose.

### TypeScript (what it is, why it’s here)

**What it is (two sentences):** TypeScript is JavaScript with a type system layered on top. It checks your code (and your component APIs) before you run it, then compiles down to regular JavaScript.

**Why Counterfoil uses it (practical reasons):**

- **The component API becomes explicit**: props are not “tribal knowledge,” they’re declared.
- **You can read code faster**: types tell you what’s allowed without spelunking every usage.
- **Refactoring is safer**: if you change a prop name, TypeScript shows you what broke.

You’ll see this constantly in Counterfoil component files: a “public API” section that defines prop types and allowed values.

From `src/components/form/Input.tsx`:

```tsx
type InputProps = {
  type?: "text" | "email" | "password" | "number" | "search"
  value?: string
  defaultValue?: string
  placeholder?: string
  disabled?: boolean
  name?: string
  id?: string

  onChange?: (value: string) => void
}
```

Even if you don’t remember TypeScript syntax yet, you can already extract real information:

- `type` is optional, and if present must be one of a small set of strings.
- `onChange` is optional, and if provided it’s a function that receives a `string`.

This is the “read the code without running it” advantage you’re aiming for. (See `2.2 What Are Types` and `2.3 TypeScript`.)

### Tailwind CSS (what it is, why it’s here)

**What it is (two sentences):** Tailwind is a utility-first CSS framework where you style elements using small class names like `flex`, `px-3`, `text-body-1`, rather than writing a new CSS class for every component. Those classes expand to CSS rules during the build.

**Why Counterfoil uses it (practical reasons):**

- It makes styling **inspectable** in the component file (you can see what’s applied).
- It encourages a constrained, repeatable vocabulary (spacing/typography patterns don’t sprawl).
- It’s compatible with a token-driven system because Tailwind can map to CSS variables.

Here’s an example of Tailwind utilities being used directly inside a component, including semantic token-based utilities:

From `src/components/form/Input.tsx`:

```tsx
className={[
  "w-full rounded",
  "bg-input-bg border border-input-border",
  "px-3 py-2",
  "text-body-1 text-text-primary",
  "placeholder:text-input-placeholder",
  "focus:outline-none focus-visible:ring-2 focus-visible:ring-input focus-visible:ring-offset-2",
  "disabled:opacity-60 disabled:cursor-not-allowed",
].join(" ")}
```

What to notice (don’t over-learn it yet):

- Some utilities are “plain Tailwind” (`w-full`, `px-3`, `flex`, etc.).
- Some are **semantic mappings** (`bg-input-bg`, `text-text-primary`) that point to CSS variables under the hood.
- You can usually read Tailwind class strings as a sentence: width, shape, colors, spacing, typography, states.

Tailwind is a big topic; this chapter just tells you it’s the “class vocabulary” you’ll see everywhere. (See `2.7 Tailwind CSS`.)

### Design tokens and semantic tokens (the styling center of gravity)

Counterfoil’s most important styling choice is that it separates:

- **Meaning and values** (tokens) from
- **How styles are applied in components** (classes / utilities)

In this repo, tokens are authored as **CSS variables**.

From `src/styles/semanticTokens.css`:

```css
:root {
  /* Backgrounds */
  --bg-primary: #ffffff;
  --bg-secondary: #f8f9fa;
  --bg-surface: #020617;

  /* Text */
  --text-primary: #000000;
  /* ... */
}
```

Those variables are then mapped into Tailwind utilities in `tailwind.config.cjs`, so you can write semantic classes like `bg-bg-primary` or `text-text-primary` instead of hardcoding colors.

From `tailwind.config.cjs`:

```js
colors: {
  bg: {
    primary: "var(--bg-primary)",
    secondary: "var(--bg-secondary)",
    surface: "var(--bg-surface)",
  },
  text: {
    primary: "var(--text-primary)",
    secondary: "var(--text-secondary)",
  },
}
```

This is the core “design system” move in Counterfoil:

- Tokens live in CSS (inspectable, overridable).
- Components refer to meaning (primary/secondary/etc.), not raw hex values.

Later chapters will show you where Tailwind is wired into the CSS pipeline and how those mappings become real CSS. (See `2.8 Where Tailwind Gets Wired` and `3.5 Tailwind Config`.)

### Vite (what it is, why it’s here)

**What it is (two sentences):** Vite is a build tool and dev server that compiles TypeScript/JSX, processes CSS, and serves your app during development with fast reloads. It also produces optimized build output for production (and in this repo, for a publishable library build).

**Why Counterfoil uses it (practical reasons):**

- Fast feedback while working on components and tokens.
- Standard tooling: minimal “custom magic.”
- Supports both “app dev” and “library build” workflows.

One practical clue that Vite is in charge: the project scripts use it directly.

From `package.json`:

```json
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "build:lib": "vite build --config vite.lib.config.ts && node scripts/build-styles.mjs"
  }
}
```

You don’t need to understand `vite.lib.config.ts` yet. The shallow point is: Counterfoil has a **development loop** (`npm run dev`) and a **library publishing loop** (`npm run build:lib`). (See `2.10 Build Pipeline` and `2.11 Packaging and Releasing`.)

### The “reading posture” to take into the rest of this guide

If your goal is to read and evolve this toolkit with confidence, your default approach should be:

- Start at the public interface (types / props).
- Then look at the style vocabulary (class maps, tokens).
- Then read the component logic (rendering and conditional behavior).
- Only then dig into build wiring and packaging.

That’s the structure of this book: tools → how they work → how Counterfoil code is organized → how to ship it.

## Next chapter

In `1.2 How They Fit Together`, we’ll draw the full pipeline at a high level—tokens → Tailwind mapping → components → build—and clarify which file is responsible for what. (See `1.2 How They Fit Together`.)

