# 1.4: What Counterfoil Is and Isn't

## Goal

Know what Counterfoil is designed to do well, what it intentionally does *not* do, and how to decide when to extend Counterfoil versus reaching for another tool.

## Key terms

- **primitive**
- **token**
- **semantic token**
- **utility class**
- **public API**
- **exports map**
- **peer dependency**
- **consuming app**

## Main content

This chapter is a boundary definition. The goal is to prevent two common failure modes:

- expecting Counterfoil to ship “complete app UI” and then fighting it
- over-extending Counterfoil to solve problems it doesn’t claim to solve

### What Counterfoil *is*

#### A toolkit for building a design system in code

Counterfoil is a library you install and import into an app. Its primary public surface is “export a bunch of components.”

From `src/index.ts`:

```ts
export * from "./components/primitives"
export * from "./components/form"
export * from "./components/data"
export * from "./components/navigation"
export * from "./icons"
```

That structure is intentional:

- **primitives**: small building blocks (Button, Text, Stack, etc.)
- **composites**: things like `InputField` that compose primitives into common patterns
- **navigation/data/form**: a light taxonomy, not a comprehensive catalog

#### A semantic token system (CSS variables as the center)

Counterfoil’s theming center is a set of CSS variables (semantic tokens) plus a mapping layer so those tokens can be used ergonomically in Tailwind.

You saw the pipeline in `1.2 How They Fit Together`. Practically, it means:

- “change the look” tends to be token edits
- components should not be the primary place you set raw colors/spacing

#### A publishable npm package with explicit entrypoints

Counterfoil is set up to be consumed as a package, not as a copy/paste kit.

From `package.json`:

```json
{
  "name": "counterfoil-starter-kit",
  "types": "./dist/index.d.ts",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "import": "./dist/counterfoil-kit.es.js",
      "require": "./dist/counterfoil-kit.umd.js"
    },
    "./styles/semanticTokens.css": {
      "import": "./dist/semanticTokens.css",
      "require": "./dist/semanticTokens.css"
    },
    "./styles/base.css": {
      "import": "./dist/base.css",
      "require": "./dist/base.css"
    },
    "./tailwind-preset": "./tailwind.config.cjs"
  }
}
```

This tells you what Counterfoil considers “public”:

- components
- styles entrypoints
- Tailwind preset

Everything else in the repo is “implementation detail” unless explicitly exported.

### What Counterfoil *isn’t*

#### It is not a complete UI product suite

Counterfoil is not trying to compete with “full catalog” component libraries (date pickers, complex data grids, advanced charts, etc.). If you need those tomorrow, you’ll either:

- integrate a specialized library, or
- build them as app-specific components on top of Counterfoil primitives

Counterfoil gives you the *language* (tokens + primitives) more than it gives you every *sentence* you’ll ever need.

#### It is not a page builder or application framework

Counterfoil does not ship:

- routing
- state management conventions
- data fetching conventions
- authentication patterns
- “app structure” decisions

Those belong in the consuming application.

#### It is not a design tool

It won’t generate layouts visually. It’s a code toolkit. If you want visual composition, you use design tools; if you want production UI, you use code.

### Boundaries and limitations (practical)

Here are the boundaries you should enforce when evolving Counterfoil:

- **Counterfoil should define reusable UI building blocks.**
- **Your app should define domain-specific components and flows.**

A quick litmus test:

- If the component’s behavior depends on your product’s domain logic (“Invoice status”, “User role”), it probably belongs in the app.
- If the component expresses a reusable UI pattern (“Table row selection”, “Input with label + help text”), it may belong in Counterfoil.

### When to use something else (decision guide)

Use Counterfoil when:

- you want to own your system’s semantics and tokens
- you want theming to be primarily CSS-variable-driven
- you want components that remain readable and modifiable

Use a different tool (or add one) when:

- you need a large catalog of complex components immediately
- you need a deeply opinionated design language with strict defaults (and you want to accept that)
- you need non-UI infrastructure (routing, state, auth) and want a full framework to decide that for you

The “wise evolution” move is not “never use other libraries.” It’s:

- keep Counterfoil small and legible
- integrate other tools at the application layer when needed
- avoid turning Counterfoil into a grab bag of unrelated features

## Next chapter

In `1.5 Navigating the Repo`, we’ll map the folder structure and answer “where is X?” so you can move through the codebase quickly when you need to change something. (See `1.5 Navigating the Repo`.)

